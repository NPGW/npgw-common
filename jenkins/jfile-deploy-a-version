@Library('npgw-lib@refactor-apply-env') _

pipeline {
    agent { label 'build-node' }

    parameters {
        string(name: 'RELEASE_VERSION', defaultValue: 'latest', description: 'Release version')
        choice(name: 'ENVIRONMENT_NAME', choices: ['test', 'dev', 'prod', 'sandbox'], description: 'Deployment environment')
        booleanParam(name: 'APPLY_TERRAFORM', defaultValue: true, description: 'If checked, terraform will be applied')
        booleanParam(name: 'RUN_TESTS', defaultValue: true, description: 'If checked, API tests will be run')
    }

    environment {
        AWS_REGION = 'eu-central-1'
        AWS_BUCKET_NAME = 'npgw-versions'
        AWS_REPOSITORY_URL = '214404897309.dkr.ecr.eu-central-1.amazonaws.com'
    }

    stages {
        stage('Validate Release Tag for Deploy Env') {
            when {
                expression {
                    return params.ENVIRONMENT_NAME in ['sandbox', 'prod']
                }
            }
            steps {
                script {
                    def requiredTag = ['sandbox': '-rc', 'prod': '-release'][params.ENVIRONMENT_NAME]
                    if (!env.RELEASE_VERSION.endsWith(requiredTag)) {
                        error("Release Version tag must be ${requiredTag} for ${params.ENVIRONMENT_NAME}, but got ${env.RELEASE_VERSION}")
                    }
                }
            }
        }

        stage('Determine AWS Role') {
            steps {
                script {
                    env.ROLE_TO_ASSUME = determineAwsRole(params.ENVIRONMENT_NAME, 'deploy')
                    echo "Assuming role: ${env.ROLE_TO_ASSUME}"
                }
            }
        }

        stage('Get Release Version') {
            steps {
                script {
                    withCredentials([string(credentialsId: 'GH_TOKEN', variable: 'GH_TOKEN')]) {
                        if (params.RELEASE_VERSION == 'latest') {
                            env.RELEASE_VERSION = sh(script: """aws ecr describe-images --repository-name npgw/merchant --query 'reverse(sort_by(imageDetails,& imagePushedAt)[-1].imageTags)[0]' --output text""", returnStdout: true).trim()
                        } else {
                            env.RELEASE_VERSION = params.RELEASE_VERSION
                        }
                    }
                }
            }
        }

        stage('Validate Release Version') {
            steps {
                script {
                    if (!env.RELEASE_VERSION) {
                        error("Release version is null. Exiting...")
                    }
                }
            }
        }

        stage('Apply terraform') {
            when {
                expression {
                    return params.APPLY_TERRAFORM
                }
            }
            steps {
                script {
                    build job: 'apply-an-environment',
                        parameters: [
                            string(name: 'RELEASE_VERSION', value: env.RELEASE_VERSION),
                            string(name: 'ENVIRONMENT_NAME', value: env.ENVIRONMENT_NAME),
                            string(name: 'ACTION', value: 'apply'),
                        ],
                        wait: true,
                        propagate: true
                }
            }
        }

        stage('Get Service List') {
            steps {
                script {
                    env.SERVICE_LIST = sh(script: "cat ${WORKSPACE}/.github/SERVICE_LIST.json", returnStdout: true).trim()
                }
            }
        }

        stage('Assume Correct AWS Role') {
            steps {
                assumeCorrectAwsRole(env.ROLE_TO_ASSUME)
            }
        }

        stage('Deploy Services') {
            steps {
                script {
                    def services = readJSON text: env.SERVICE_LIST
                    for (service in services) {
                        def taskDefinition = service.serviceName
                        def imageUrl = "${env.AWS_REPOSITORY_URL}/npgw/${service.repoName}:${env.RELEASE_VERSION}"
                        def clusterName = service.clusterName

                        sh """
                        aws ecs describe-task-definition --task-definition ${taskDefinition} > task.json
                        jq --arg IMAGE "${imageUrl}" '.taskDefinition | .containerDefinitions[0].image = \$IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' task.json > new-task.json
                        aws ecs register-task-definition --family ${taskDefinition} --cli-input-json file://new-task.json
                        TASK_REVISION=\$(aws ecs describe-task-definition --task-definition ${taskDefinition} --query 'taskDefinition.revision' --output text)
                        aws ecs update-service --cluster ${clusterName} --service ${taskDefinition} --task-definition ${taskDefinition}:\$TASK_REVISION --force-new-deployment
                        until aws ecs describe-services --cluster ${clusterName} --services ${taskDefinition} --query "services[0].deployments[?status=='PRIMARY'].rolloutState" --output text | grep -q "COMPLETED"; do echo "Waiting... rolloutState=\$rolloutState" sleep 10; done
                        """
                    }
                }
            }
        }

        stage('Fetch portal and docs builds') {
            steps {
                script {
                    def targetBucketName = "${params.ENVIRONMENT_NAME}.npgw.xyz"
                    def targetDocsBucketName = "docs.${params.ENVIRONMENT_NAME}.npgw.xyz"
                    if (params.ENVIRONMENT_NAME == 'prod') {
                        targetBucketName = "npgw.xyz"
                        targetDocsBucketName = "docs.npgw.xyz"
                    }

                    sh """
                        aws s3 sync s3://${env.AWS_BUCKET_NAME}/npgw-portal/${env.RELEASE_VERSION}/ s3://${targetBucketName} --delete
                        aws s3 sync s3://${env.AWS_BUCKET_NAME}/npgw-common/${env.RELEASE_VERSION}/docs s3://${targetDocsBucketName}/docs --delete
                    """
                }
            }
        }


        stage('Invalidate CloudFront Caches') {
            steps {
                script {
                    withEnv([
                        'AWS_ACCESS_KEY_ID=',
                        'AWS_SECRET_ACCESS_KEY=',
                        'AWS_SESSION_TOKEN='
                    ]) {
                        def distributionIds = sh(
                          script: """
                            aws cloudfront list-distributions \
                              --region us-east-1 \
                              --query "DistributionList.Items[].Id" \
                              --output text
                          """,
                          returnStdout: true
                        ).trim().split()

                        if (!distributionIds) {
                            error("Error: No CloudFront Distribution IDs found in root account")
                        }

                        distributionIds.each { distId ->
                            sh "aws cloudfront create-invalidation --distribution-id ${distId} --paths '/*'"
                        }
                    }
                }
            }
        }

        stage('Test deployed service') {
            when {
                expression {
                    return params.RUN_TESTS
                }
            }
            steps {
                script {
                    build job: 'test-an-environment',
                        parameters: [
                            string(name: 'RELEASE_VERSION', value: env.RELEASE_VERSION),
                            string(name: 'ENVIRONMENT_NAME', value: env.ENVIRONMENT_NAME)
                        ],
                        wait: true,
                        propagate: true
                }
            }
        }
    }

    post {
        always {
            script {
                currentBuild.description = "RELEASE_VERSION=${env.RELEASE_VERSION}, ENVIRONMENT_NAME=${params.ENVIRONMENT_NAME}"
            }
            cleanWs()
        }
    }
}