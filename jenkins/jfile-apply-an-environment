pipeline {
  agent { label 'build-node' }

  parameters {
    choice(name: 'ENVIRONMENT_NAME', choices: ['test', 'dev', 'sandbox', 'prod'], description: 'Target environment')
    string(name: 'IMAGE_TAG', defaultValue: 'latest', description: 'ECR image tag to use')
    choice(name: 'TERRAFORM_ACTION', choices: ['plan', 'apply', 'destroy'], description: 'Terraform action to perform')
  }

  environment {
    AWS_REGION         = 'eu-central-1'
    IMAGE_REPO         = '214404897309.dkr.ecr.eu-central-1.amazonaws.com/npgw/merchant'
    PROVIDER_TF_PATH   = 'infra/provider.tf'
    VARS_FILE_PATH     = 'infra/var.tfvars'
    OPENAPI_MERCHANT   = 'https://docs.npgw.xyz/merchant-v1.yaml'
    OPENAPI_PORTAL     = 'https://docs.npgw.xyz/portal-v1.yaml'
  }

  stages {
    stage('Checkout') {
      steps {
        git branch: 'main', credentialsId: 'github-pat', url: 'https://github.com/NPGW/npgw-terraform.git'
      }
    }

    stage('Determine AWS Role') {
      steps {
        script {
          def roles = [
            'test'   : 'arn:aws:iam::820242903147:role/npgw-terraform-github-oidc-provider',
            'dev'    : 'arn:aws:iam::872515291967:role/npgw-terraform-github-oidc-provider',
            'prod'   : 'arn:aws:iam::721719382766:role/npgw-terraform-github-oidc-provider',
            'sandbox': 'arn:aws:iam::225989351233:role/npgw-terraform-github-oidc-provider'
          ]

          def selectedRole = roles[params.ENVIRONMENT_NAME]
          if (!selectedRole) {
            error("Invalid environment: ${params.ENVIRONMENT_NAME}")
          }

          env.ROLE_TO_ASSUME = selectedRole
          echo "Assuming role: ${env.ROLE_TO_ASSUME}"
        }
      }
    }

    stage('Assume Role') {
      steps {
        script {
          def creds = sh(script: """
            aws sts assume-role \
              --role-arn ${env.ROLE_TO_ASSUME} \
              --role-session-name jenkins-${params.ENVIRONMENT_NAME} \
              --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
              --output text
          """, returnStdout: true).trim().split()

          env.AWS_ACCESS_KEY_ID     = creds[0]
          env.AWS_SECRET_ACCESS_KEY = creds[1]
          env.AWS_SESSION_TOKEN     = creds[2]
        }
      }
    }

    stage('Configure provider.tf backend') {
      steps {
        dir('infra') {
          sh "sed -i 's|npgw-terraform-state-|npgw-terraform-state-${params.ENVIRONMENT_NAME}|' provider.tf"
        }
      }
    }

    stage('Create var.tfvars') {
      steps {
        dir('infra') {
          sh """
            echo 'image_source_tag = "${IMAGE_REPO}:${params.IMAGE_TAG}"' > var.tfvars
          """
        }
      }
    }

    stage('Resolve latest ECR tag if IMAGE_TAG == latest') {
      when {
        expression { params.IMAGE_TAG == 'latest' }
      }
      steps {
        dir('infra') {
          script {
            def latestTag = sh(
              script: """
                aws ecr list-images \
                  --repository-name "npgw/merchant" \
                  --region ${env.AWS_REGION} \
                  --registry-id "214404897309" \
                  --query 'imageIds[*].imageTag' \
                  --output text | tr '\\t' '\\n' | sort -r | head -n 1
              """,
              returnStdout: true
            ).trim()
            echo "Resolved latest tag: ${latestTag}"
            sh "echo 'image_tag = \"${latestTag}\"' >> var.tfvars"
          }
        }
      }
    }

    stage('Download OpenAPI specs') {
      steps {
        dir('infra') {
          sh """
            wget ${OPENAPI_MERCHANT}
            wget ${OPENAPI_PORTAL}
          """
        }
      }
    }

    stage('Terraform Init') {
      steps {
        dir('infra') {
          sh "terraform init -upgrade -reconfigure"
        }
      }
    }

    stage('Terraform Plan') {
      when {
        expression { params.TERRAFORM_ACTION == 'plan' || params.TERRAFORM_ACTION == 'apply' }
      }
      steps {
        dir('infra') {
          sh "terraform plan -var='environment=${params.ENVIRONMENT_NAME}' -var-file=var.tfvars"
        }
      }
    }

    stage('Terraform Apply') {
      when {
        expression { params.TERRAFORM_ACTION == 'apply' }
      }
      steps {
        dir('infra') {
          // No manual approval for apply
          sh "terraform apply -auto-approve -var='environment=${params.ENVIRONMENT_NAME}' -var-file=var.tfvars"
        }
      }
    }

    stage('Terraform Destroy') {
      when {
        expression { params.TERRAFORM_ACTION == 'destroy' }
      }
      steps {
        dir('infra') {
          script {
            def confirmation = input(
              message: "⚠️ Confirm destroy of ${params.ENVIRONMENT_NAME}",
              parameters: [
                string(name: "CONFIRMATION", description: 'Type "destroy" to confirm')
              ]
            )
            if (confirmation != 'destroy') {
              error("❌ Destroy not confirmed. You typed '${confirmation}' instead of 'destroy'. Aborting")
            }
          }
          
          sh "terraform destroy -auto-approve -var='environment=${params.ENVIRONMENT_NAME}' -var-file=var.tfvars"
        }
      }
    }
  }
}